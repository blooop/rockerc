import sys
import subprocess
import pathlib
import yaml  # Re-added for local YAML parsing
import os
import logging


def yaml_dict_to_args(d: dict) -> str:
    """Given a dictionary of arguments turn it into an argument string to pass to rocker

    Args:
        d (dict): rocker arguments dictionary

    Returns:
        str: rocker arguments string
    """

    cmd_parts = []

    image = d.pop("image", None)  # special value
    d.pop("disable_args", None)

    # Add all --arg options
    if "args" in d:
        args = d.pop("args")
        for a in args:
            cmd_parts.append(f"--{a}")

    # Track if we need to insert '--' before image
    needs_double_dash = False

    for k, v in d.items():
        if k == "image":
            continue  # skip image, will add as positional argument

        if isinstance(v, list):
            cmd_parts.append(f"--{k}")
            for item in v:
                cmd_parts.append(str(item))
            if k == "extension-blacklist" and v:
                needs_double_dash = True
        else:
            cmd_parts.append(f"--{k}")
            cmd_parts.append(str(v))

    # Insert '--' before image if needed
    if image is not None:
        if needs_double_dash:
            cmd_parts.append("--")
        cmd_parts.append(str(image))

    return cmd_parts


# NOTE: collect_arguments is now imported from renv, which parses defaults and passes them as arguments.
def build_docker(dockerfile_path: str = ".") -> str:
    """Build a Docker image from a Dockerfile and return an autogenerated image tag based on where rocker was run.

    Args:
        dockerfile_path (str, optional): Path to the Dockerfile. Defaults to ".".

    Returns:
        str: The tag of the built Docker image.
    """

    tag = f"{pathlib.Path().absolute().name.lower()}:latest"
    dockerfile_dir = pathlib.Path(dockerfile_path).absolute().parent
    subprocess.call(["docker", "build", "-t", tag, str(dockerfile_dir)])
    return tag


def save_rocker_cmd(split_cmd: str):
    dry_run = split_cmd + ["--mode", "dry-run"]
    try:
        s = subprocess.run(dry_run, capture_output=True, text=True, check=True)
        output = s.stdout
        # Split by "vvvvvv" to discard the top section
        _, after_vvvvvv = output.split("vvvvvv", 1)
        # Split by "^^^^^^" to get the second section
        section_to_save, after_caret = after_vvvvvv.split("^^^^^^", 1)
        # Save the Dockerfile section
        with open("Dockerfile.rocker", "w", encoding="utf-8") as dockerfile:
            dockerfile.write("#This file was autogenerated by rockerc\n")  # Add the shebang
            dockerfile.write(section_to_save.strip())
        # Find the "run this command" section
        run_command_section = after_caret.split("Run this command: ", 1)[-1].strip()
        formatted_script_lines = []
        lines = run_command_section.split()
        formatted_script_lines.append("#!/bin/bash")
        formatted_script_lines.append("# This file was autogenerated by rockerc")
        formatted_script_lines.append("docker run \\")

        for i, line in enumerate(
            lines[2:], start=2
        ):  # Skip 'docker run' which is split in the first two items
            if i < len(lines) - 1:
                formatted_script_lines.append(f"  {line} \\")
            else:
                formatted_script_lines.append(f"  {line}")

        formatted_script_content = "\n".join(formatted_script_lines)

        bash_script_path = "run_dockerfile.sh"
        with open(bash_script_path, "w", encoding="utf-8") as bash_script:
            bash_script.write(formatted_script_content)

        # Make the bash script executable
        os.chmod(bash_script_path, 0o755)

        logging.info(
            f"Files have been saved:\n - Dockerfile.rocker\n - {bash_script_path} (executable)"
        )
    except subprocess.CalledProcessError as e:
        logging.error("[rockerc] Error: rocker dry-run failed.")
        logging.error(f"[rockerc] Command: {' '.join(dry_run)}")
        logging.error(f"[rockerc] Exit code: {e.returncode}")
        logging.error(f"[rockerc] Output:\n{e.stdout}")
        logging.error(f"[rockerc] Error output:\n{e.stderr}")
        logging.error(
            "[rockerc] This likely means rocker or one of its extensions failed to generate a Dockerfile. Please check your rockerc.yaml and rocker installation."
        )
        sys.exit(e.returncode)
    except ValueError as e:
        logging.error(f"[rockerc] Error processing the output from rocker dry-run: {e}")
        logging.error(
            "[rockerc] The output format may have changed or rocker failed to generate the expected output."
        )
        sys.exit(1)


def container_exists(container_name: str) -> bool:
    """Check if a Docker container with the given name exists.

    Args:
        container_name: Name of the container to check

    Returns:
        bool: True if container exists, False otherwise
    """
    try:
        result = subprocess.run(
            [
                "docker",
                "ps",
                "-a",
                "--filter",
                f"name=^/{container_name}$",
                "--format",
                "{{.Names}}",
            ],
            capture_output=True,
            text=True,
            check=True,
        )
        return container_name in result.stdout.strip().split("\n")
    except subprocess.CalledProcessError:
        return False


def container_is_running(container_name: str) -> bool:
    """Check if a Docker container is currently running.

    Args:
        container_name: Name of the container to check

    Returns:
        bool: True if container is running, False otherwise
    """
    try:
        result = subprocess.run(
            ["docker", "ps", "--filter", f"name=^/{container_name}$", "--format", "{{.Names}}"],
            capture_output=True,
            text=True,
            check=True,
        )
        return container_name in result.stdout.strip().split("\n")
    except subprocess.CalledProcessError:
        return False


def attach_to_container(container_name: str) -> None:
    """Attach to an existing Docker container.

    Args:
        container_name: Name of the container to attach to
    """
    try:
        if not container_is_running(container_name):
            logging.info(f"Container '{container_name}' exists but is not running. Starting it...")
            subprocess.run(["docker", "start", container_name], check=True)

        logging.info(f"Attaching to existing container '{container_name}'...")
        # Always start in /workspaces (where the repo is mounted)
        workdir = "/workspaces"
        subprocess.run(
            ["docker", "exec", "-it", "-w", workdir, container_name, "/bin/bash"], check=True
        )

    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to attach to container '{container_name}': {e}")
        # If we can't attach, suggest removing the conflicting container
        logging.error("You may need to remove the existing container:")
        logging.error(f"  docker rm {container_name}")
        logging.error("Or remove it forcefully if it's running:")
        logging.error(f"  docker rm -f {container_name}")
        raise


def extract_container_name_from_args(split_cmd: list) -> str:
    """Extract container name from rocker command arguments.

    Args:
        split_cmd: List of command arguments

    Returns:
        str: Container name or empty string if not found
    """
    try:
        # Look for --name argument
        name_index = split_cmd.index("--name")
        if name_index + 1 < len(split_cmd):
            return split_cmd[name_index + 1]
    except ValueError:
        pass
    return ""


def collect_arguments(path: str = ".") -> dict:
    """Search for rockerc.yaml files and return a merged dictionary

    Args:
        path (str, optional): path to reach for files. Defaults to ".".

    Returns:
        dict: A dictionary of merged rockerc arguments
    """
    search_path = pathlib.Path(path)

    # Start with defaults passed in as command line arguments (from renv)
    merged_dict = {"args": []}

    # Load and merge local rockerc.yaml files
    local_configs_found = False
    for p in search_path.glob("rockerc.yaml"):
        print(f"loading {p}")
        local_configs_found = True

        with open(p.as_posix(), "r", encoding="utf-8") as f:
            local_config = yaml.safe_load(f) or {}

            # Handle disable_args - remove these from the current args
            if "disable_args" in local_config:
                disabled_args = local_config["disable_args"]
                if isinstance(disabled_args, list):
                    for arg in disabled_args:
                        if arg in merged_dict["args"]:
                            merged_dict["args"].remove(arg)
                    print(f"Local disabled extensions: {', '.join(disabled_args)}")

                # Remove disable_args so it doesn't get passed to rocker
                local_config.pop("disable_args")

            # Handle regular args - add these to existing args (avoiding duplicates)
            if "args" in local_config:
                local_args = local_config["args"]
                if isinstance(local_args, list):
                    for arg in local_args:
                        if arg not in merged_dict["args"]:
                            merged_dict["args"].append(arg)
                    print(f"Added extensions: {', '.join(local_args)}")

                # Remove args from local_config since we handled it specially
                local_config.pop("args")

            # Merge other configuration options (image, dockerfile, etc.)
            for key, value in local_config.items():
                merged_dict[key] = value

    # If no local config found, show what defaults are being used
    if not local_configs_found:
        if merged_dict["args"]:
            print(f"Using default extensions: {', '.join(merged_dict['args'])}")
        print("No local rockerc.yaml found - using defaults. Create rockerc.yaml to customize.")

    return merged_dict


def run_rockerc(path: str = "."):
    """run rockerc by searching for rocker.yaml in the specified directory and passing those arguments to rocker

    Args:
        path (str, optional): Search path for rockerc.yaml files. Defaults to ".".
    """

    logging.basicConfig(level=logging.INFO)
    merged_dict = collect_arguments(path)

    # Fix: If no local config, use hardcoded defaults
    if not merged_dict or (not merged_dict.get("args") and not merged_dict.get("image")):
        merged_dict = {
            "image": "ubuntu:24.04",
            "args": ["user", "pull", "deps", "git", "cwd"],
            "disable_args": ["nvidia"],
        }
        print("No local rockerc.yaml found - using hardcoded defaults.")

    if "args" not in merged_dict:
        logging.error(
            "No 'args' key found in rockerc.yaml or defaults. Please add an 'args' list with rocker arguments. See 'rocker -h' for help."
        )
        sys.exit(1)

    if "dockerfile" in merged_dict:
        logging.info("Building dockerfile...")
        merged_dict["image"] = build_docker(merged_dict["dockerfile"])
        logging.info("disabling 'pull' extension as a Dockerfile is used instead")
        if "pull" in merged_dict["args"]:
            merged_dict["args"].remove("pull")  # can't pull as we just build image
        # remove the dockerfile command as it does not need to be passed onto rocker
        merged_dict.pop("dockerfile")

    create_dockerfile = False
    if "create-dockerfile" in merged_dict["args"]:
        merged_dict["args"].remove("create-dockerfile")
        create_dockerfile = True


    cmd_args = yaml_dict_to_args(merged_dict)
    cmd = ["rocker"] + cmd_args
    # Forward any extra CLI arguments to the container
    extra_args = sys.argv[1:]
    # Remove any known options (e.g. -h, --help) and config file args
    # Only forward arguments that are not part of the config
    # If the first arg is a YAML file or repo spec, skip it
    if extra_args:
        # Remove repo spec or config file if present
        if extra_args[0].endswith(".yaml") or "/" in extra_args[0]:
            extra_args = extra_args[1:]
        # Remove known options
        filtered_args = [a for a in extra_args if not a.startswith("-")]
        if filtered_args:
            cmd += filtered_args
    logging.info(f"running cmd: {' '.join(cmd)}")

    if create_dockerfile:
        save_rocker_cmd(cmd)
    else:
        container_name = extract_container_name_from_args(cmd)
        if container_name and container_exists(container_name):
            logging.info(
                f"Container '{container_name}' already exists. Attaching to it instead of creating a new one."
            )
            attach_to_container(container_name)
            return

        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            error_output = str(e)
            if container_name and ("already in use" in error_output or "Conflict" in error_output):
                logging.info(
                    f"Container name conflict detected. Attempting to attach to existing container '{container_name}'..."
                )
                if container_exists(container_name):
                    attach_to_container(container_name)
                    return

                logging.error(
                    f"Container '{container_name}' was reported as conflicting but doesn't exist. This is unexpected."
                )
            raise



if __name__ == "__main__":
    run_rockerc()
