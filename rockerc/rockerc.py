import sys
import subprocess
import pathlib
import yaml
import os
import logging
import argparse
from typing import List


def yaml_dict_to_args(d: dict) -> str:
    """Given a dictionary of arguments turn it into an argument string to pass to rocker

    Args:
        d (dict): rocker arguments dictionary

    Returns:
        str: rocker arguments string
    """

    cmd_list = []

    image = d.pop("image", None)  # special value

    if "args" in d:
        args = d.pop("args")
        # Remove whitespace-only arguments
        args = [arg.strip() for arg in args if arg.strip()]
        for a in args:
            cmd_list.extend([f"--{a}"])

    # the rest of the named arguments
    for k, v in d.items():
        cmd_list.extend([f"--{k}", str(v)])

    # last argument is the image name
    if image is not None:
        cmd_list.append(str(image))

    return " ".join(cmd_list)


def collect_arguments(path: str = ".") -> dict:
    """Search for rockerc.yaml files recursively upward and return a merged dictionary.

    Behavior:
    - Searches recursively upward from the provided path for `rockerc.yaml` or `.rockerc.yaml`.
    - Starts from the given path and moves up parent directories until a config file is found.
    - If no config file is found during upward search, falls back to `~/.rockerc.yaml`.
    - If still not found, returns an empty dict (no extensions by default).

    Args:
        path (str, optional): Starting path to search from. Defaults to ".".

    Returns:
        dict: A dictionary of merged rockerc arguments
    """
    search_path = pathlib.Path(path).resolve()
    merged_dict = {}

    # Search recursively upward for rockerc.yaml or .rockerc.yaml
    current_path = search_path
    while True:
        # Check for both rockerc.yaml and .rockerc.yaml in current directory
        for config_name in ["rockerc.yaml", ".rockerc.yaml"]:
            config_file = current_path / config_name
            if config_file.exists():
                print(f"loading {config_file}")
                with open(config_file.as_posix(), "r", encoding="utf-8") as f:
                    try:
                        yaml_content = yaml.safe_load(f)
                        if yaml_content is not None and isinstance(yaml_content, dict):
                            merged_dict.update(yaml_content)
                            return merged_dict
                        if yaml_content is not None:
                            print(
                                f"Error: YAML file {config_file} must contain a dictionary, not {type(yaml_content).__name__}"
                            )
                            sys.exit(1)
                    except yaml.YAMLError as e:
                        print(f"Error: Failed to parse YAML file {config_file}: {e}")
                        sys.exit(1)

        # Move to parent directory
        parent = current_path.parent
        if parent == current_path:  # Reached filesystem root
            break
        current_path = parent

    # Fallback: ~/.rockerc.yaml if none found during upward search
    if not merged_dict:
        home_rc = pathlib.Path.home() / ".rockerc.yaml"
        if home_rc.exists():
            print(f"loading {home_rc}")
            with open(home_rc.as_posix(), "r", encoding="utf-8") as f:
                try:
                    yaml_content = yaml.safe_load(f)
                    if yaml_content is not None and isinstance(yaml_content, dict):
                        merged_dict.update(yaml_content)
                    elif yaml_content is not None:
                        print(
                            f"Error: YAML file {home_rc} must contain a dictionary, not {type(yaml_content).__name__}"
                        )
                        sys.exit(1)
                except yaml.YAMLError as e:
                    print(f"Error: Failed to parse YAML file {home_rc}: {e}")
                    sys.exit(1)

    return merged_dict


def build_docker(dockerfile_path: str = ".") -> str:
    """Build a Docker image from a Dockerfile and return an autogenerated image tag based on where rocker was run.

    Args:
        dockerfile_path (str, optional): Path to the Dockerfile. Defaults to ".".

    Returns:
        str: The tag of the built Docker image.
    """

    tag = f"{pathlib.Path().absolute().name.lower()}:latest"
    dockerfile_dir = pathlib.Path(dockerfile_path).absolute().parent
    subprocess.call(["docker", "build", "-t", tag, str(dockerfile_dir)])
    return tag


def save_rocker_cmd(split_cmd: List[str], show_dockerfile: bool = False):
    dry_run = split_cmd + ["--mode", "dry-run"]
    try:
        s = subprocess.run(dry_run, capture_output=True, text=True, check=True)
        output = s.stdout
        # Split by "vvvvvv" to discard the top section
        _, after_vvvvvv = output.split("vvvvvv", 1)
        # Split by "^^^^^^" to get the second section
        section_to_save, after_caret = after_vvvvvv.split("^^^^^^", 1)
        # Save the Dockerfile section
        with open("Dockerfile.rocker", "w", encoding="utf-8") as dockerfile:
            dockerfile.write("#This file was autogenerated by rockerc\n")  # Add the shebang
            dockerfile.write(section_to_save.strip())
        # Find the "run this command" section
        run_command_section = after_caret.split("Run this command: ", 1)[-1].strip()
        formatted_script_lines = []
        lines = run_command_section.split()
        formatted_script_lines.append("#!/bin/bash")
        formatted_script_lines.append("# This file was autogenerated by rockerc")
        formatted_script_lines.append("docker run \\")

        for i, line in enumerate(
            lines[2:], start=2
        ):  # Skip 'docker run' which is split in the first two items
            if i < len(lines) - 1:
                formatted_script_lines.append(f"  {line} \\")
            else:
                formatted_script_lines.append(f"  {line}")

        formatted_script_content = "\n".join(formatted_script_lines)

        bash_script_path = "run_dockerfile.sh"
        with open(bash_script_path, "w", encoding="utf-8") as bash_script:
            bash_script.write(formatted_script_content)

        # Make the bash script executable
        os.chmod(bash_script_path, 0o755)

        if show_dockerfile:
            logging.info(
                f"Files have been saved:\n - Dockerfile.rocker\n - {bash_script_path} (executable)"
            )
            print("\nGenerated Dockerfile content:")
            print("=" * 50)
            print(section_to_save.strip())
            print("=" * 50)
        else:
            logging.info(f"Files saved: Dockerfile.rocker, {bash_script_path} (executable)")
    except subprocess.CalledProcessError as e:
        logging.error("[rockerc] Error: rocker dry-run failed.")
        logging.error(f"[rockerc] Command: {' '.join(dry_run)}")
        logging.error(f"[rockerc] Exit code: {e.returncode}")
        logging.error(f"[rockerc] Output:\n{e.stdout}")
        logging.error(f"[rockerc] Error output:\n{e.stderr}")
        logging.error(
            "[rockerc] This likely means rocker or one of its extensions failed to generate a Dockerfile. Please check your rockerc.yaml and rocker installation."
        )
        sys.exit(e.returncode)
    except ValueError as e:
        logging.error(f"[rockerc] Error processing the output from rocker dry-run: {e}")
        logging.error(
            "[rockerc] The output format may have changed or rocker failed to generate the expected output."
        )
        sys.exit(1)


def parse_cli_args():
    """Parse command line arguments for rockerc"""
    parser = argparse.ArgumentParser(
        description="rockerc - A tool to parse rockerc.yaml files and pass arguments to rocker",
        add_help=False  # We'll handle help manually to pass through to rocker when needed
    )

    parser.add_argument("--show-dockerfile", action="store_true",
                       help="Show the generated Dockerfile content when creating Dockerfiles")
    parser.add_argument("--help", "-h", action="store_true",
                       help="Show this help message and exit")

    # Parse known args so we can pass unknown ones to rocker
    known_args, unknown_args = parser.parse_known_args()

    if known_args.help:
        parser.print_help()
        print("\nAdditional rocker arguments will be passed through to rocker.")
        print("Run 'rocker --help' to see rocker-specific options.")
        sys.exit(0)

    return known_args, unknown_args


def show_config_info(merged_dict: dict, config_files_loaded: List[str]):
    """Display information about loaded configuration and extensions"""
    print("rockerc configuration:")

    if config_files_loaded:
        print(f"  Config files: {', '.join(config_files_loaded)}")
    else:
        print("  Config files: None found")

    if "image" in merged_dict:
        print(f"  Base image: {merged_dict['image']}")

    extensions = merged_dict.get("args", [])
    if extensions:
        print(f"  Extensions: {', '.join(extensions)}")
    else:
        print("  Extensions: None")

    print()  # Empty line for separation


def run_rockerc(path: str = "."):
    """run rockerc by searching for rocker.yaml in the specified directory and passing those arguments to rocker

    Args:
        path (str, optional): Search path for rockerc.yaml files. Defaults to ".".
    """
    # Parse CLI arguments first
    known_args, unknown_args = parse_cli_args()

    logging.basicConfig(level=logging.INFO, format='%(message)s')

    # Track which config files were loaded for display
    config_files_loaded = []

    # Temporarily capture the print statements from collect_arguments
    import builtins
    original_print = builtins.print
    def capture_print(*args, **kwargs):
        if args and "loading" in str(args[0]):
            config_files_loaded.append(str(args[0]).replace("loading ", ""))
        # Don't print the loading messages anymore

    builtins.print = capture_print
    merged_dict = collect_arguments(path)
    builtins.print = original_print

    # If no config found anywhere, continue with no extensions by default.
    # If a config is found but has no 'args', treat as empty list (no extensions).
    if "args" not in merged_dict:
        merged_dict["args"] = []

    # Show configuration info
    show_config_info(merged_dict, config_files_loaded)

    if "dockerfile" in merged_dict:
        logging.info("Building dockerfile...")
        merged_dict["image"] = build_docker(merged_dict["dockerfile"])
        logging.info("Disabling 'pull' extension as a Dockerfile is used instead")
        if "pull" in merged_dict["args"]:
            merged_dict["args"].remove("pull")  # can't pull as we just build image
        # remove the dockerfile command as it does not need to be passed onto rocker
        merged_dict.pop("dockerfile")

    args: List[str] = merged_dict.get("args", [])

    # Handle CLI args separately - filter out --create-dockerfile and pass rest through
    cli_args = [arg for arg in unknown_args if arg != "--create-dockerfile"]
    create_dockerfile = "--create-dockerfile" in unknown_args

    # Also check for --create-dockerfile in config args
    if "--create-dockerfile" in args:
        args = [arg for arg in args if arg != "--create-dockerfile"]
        create_dockerfile = True

    # Update merged_dict to only contain YAML args (for extensions from config)
    merged_dict["args"] = args

    # Get the arguments from the YAML config (this handles config-based extensions)
    yaml_cmd_args_str = yaml_dict_to_args(merged_dict)

    # Combine YAML args with CLI args
    if yaml_cmd_args_str:
        yaml_cmd_args = yaml_cmd_args_str.split()
        cmd_args = yaml_cmd_args + cli_args
    else:
        cmd_args = cli_args

    if not cmd_args:
        logging.error("No rocker arguments provided. No rockerc.yaml found locally or in ~/.rockerc.yaml, and no CLI args given.")
        logging.error("Run 'rockerc --help' for usage information or 'rocker --help' for rocker options.")
        return

    cmd = ["rocker"] + cmd_args
    logging.info("Running: %s", " ".join(cmd))

    if create_dockerfile:
        save_rocker_cmd(cmd, known_args.show_dockerfile)
    subprocess.run(cmd, check=True)


if __name__ == "__main__":
    run_rockerc()
